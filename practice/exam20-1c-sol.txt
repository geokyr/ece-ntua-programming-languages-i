1.α)
<expr> ::= <expr> + <mult> | <expr> - <expr> | <mult>
<mult> ::= <mult> * <fact> | <mult> / <mult> | <fact>
<fact> ::= ( <expr> ) | a | b | c


1.β)
<expr> ::= <expr> + <mult> | <expr> - <expr> | <new>
<new> ::= <new> % <mult> | <mult>
<mult> ::= <mult> * <fact> | <mult> / <mult> | <fact>
<fact> ::= ( <expr> ) | a | b | c


1.γ)
<eq> ::= <expr> = <eq> | <expr>
<expr> ::= <expr> + <mult> | <expr> - <expr> | <new>
<new> ::= <new> % <mult> | <mult>
<mult> ::= <mult> * <fact> | <mult> / <mult> | <fact>
<fact> ::= ( <expr> ) | a | b | c

--------------------------------------------------------------------------------

2.α)
Όταν καλούμε sum(generator) ο generator κάνει yield μέχρι να "αδειάσει", έπειτα δεν έχει άλλα στοιχεία και γι αυτό η τιμή που επιστρέφεται είναι η κενή λίστα []. Μία λύση είναι να κρατήσουμε τα στοιχεία που κάνει yield ο generator σε μία λίστα l για να μπορούμε να κάνουμε iteration σε αυτή.

def f(a):
    l = list(a)
    s = sum(l)
    return [x/s for x in l]


2.β)
(* Απλά προσθέτουμε το n ως όρισμα της check *)
fun check k n =
  k * k > n orelse
  n mod k <> 0 andalso
  check (k+2) n;

fun prime 2 = true
  | prime n = n mod 2 <> 0 andalso check 3 n;


2.γ) (ΑΜ2==9, ΑΜ3==4)
2.γ1)
9 17 42 4 9 17

2.γ2)
9 17 42 4 42 4

2.δ) (ΑΜ2 == 9, ΑΜ3 == 4)
2.δ1) 9 9 4 17
2.δ2) 4 4 17 9

--------------------------------------------------------------------------------

3.
Θέλουμε να μιμηθούμε το call by value-result. Γι' αυτό το λόγο θα αντιγράψουμε
τις τιμές από τις πραγματικές μεταβλητές σε τοπικές μεταβλητές (copy-in), θα
κάνουμε ό,τι ήταν να κάνουμε με αυτές, και στο τέλος θα ξαναγράψουμε τα
αποτελέσματα στις πραγματικές μεταβλητές.

procedure p(byreference x, y: integer);
    int local_x = x; // αντιγραφή τιμής
    int local_y = y; // σε τοπικές μεταβλητές
    <body> // στο σώμα της body πρέπει να αλλάξουμε τα x, y σε local_x, local_y
    x = local_x
    y = local_y

--------------------------------------------------------------------------------

4. (Ocaml)

let rec reconstruct l =
  let rec aux curr n l acc =
    if n > 0 then
      match l with
      | [] -> acc
      | h :: t -> aux (h :: curr) (n-1) t acc
    else
      match l with
      | [] -> List.rev curr :: acc
      | h :: t -> aux [h] h t (List.rev curr :: acc)
  in
  match l with
  | [] -> []
  | h :: t -> List.rev (aux [h] h t [])
;;

--------------------------------------------------------------------------------

5. Δεν ξέρω prolog :(

--------------------------------------------------------------------------------

6.
Υποθέτουμε πως οι κορυφές του γραφήματος
αναπαρίστανται από τους ακεραίους {0, 1, ...., Ν-1}.
και το G είναι λίστα από λίστες, όπως στο παραδειγμα παρακάτω.
Θα μπορούσαμε να βελτιώσουμε την πολυπλοκότητα σε O(1) για τις out_degree, in_degree,
αν δεν θέλαμε ακριβώς πίνακα γειτνίασης, αλλά μπορούσαμε να φτιάξουμε δική μας
κλάση που να υποστηρίζει αυτά τα operations.

def adj_list_mat(G):
    """ O(n*n), where n == len(G)"""
    n = len(G)
    M = [[0]*n for _ in range(n)]
    for v in range(n):
        for neighbor in G[v]:
            M[v][neighbor] = 1
    return M

def out_degree(M, u):
    """ O(n) where n == len(M[u]) == len(M[0]) """
    return sum(M[u])

def in_degree(M, u):
    """ O(n) where n == len(M)"""
    return sum(M[i][u] for i in range(len(M)))

def test():
    G = [
        [1, 2],
        [0],
        [0, 1, 3],
        [0]
    ]
    M = adj_list_mat(G)
    for row in M:
        print(row)
    print(out_degree(M, 2)) #expected: 3
    print(in_degree(M, 2)) #expected: 1
